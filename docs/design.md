Design
======


Overview
--------

At the core we are creating a permission table which every view is using at runtime
before executing the view.


Permission table
----------------

The table is generated by 3 avenues:

  1. A main config
  2. Config per view (by a class variable)
  3. Config per view action (by a decorator)

All these avenues are combined. Conflicting configurations will raise a ImproperlyConfigured exception.


Patching views
--------------

Patching is done slightly different for Django and Django REST. The biggest difference
is that Django REST will call check_permissions() before calling the method view.

## Django

* Function views are patched directly from the resolvers to urlpatterns.
* Class merthod views are patched in case of classes. This ensures that every
  view called by dispatch() will do a check.

## Django REST

Django functions essentially become methods to a WrappedAPI class so we treat both
functions and class-based views the same.

* Patching occurs at the check_permissions() method. We can't patch directly the
  class views like in Django since then check_permissions() would overshadow our
  checks - in many cases not being called at all.

dispatch() --> initial() --> check_permissions() --> get() --> retrieve()


Building permission registry
----------------------------

For convenience we keep a role and permission lookup table stored as PERMISSION_REGISTRY.

The lookup is built incrementally in these ways:
  1. Initially built by looking for a central configuration based on settings.
  2. Looking for view_permissions in any used classes.
  3. At runtime for decorated views with @allowed and @disallowed

The lookup table has this structure:
  <view>.<action>

Note: the entries in the lookup are sorted based on @expensive and @cheap.


Determining permissions
-----------------------

Permissions are determined by

This wrapper runs before every view and performs role checking and then
permission checking on a matched role.

The biggest issue is getting the implementation to work for both Django and Django REST framework and
also be able to use the framework in different ways.

Solution: Patch based on urlpatterns. This ensures that we don't care

1. Build permissions registry from all url.
2. Organize as a fast lookup.
  - Set view

1. Get all pairs of URL, view.
2. Patch all views with permission and



All views:


    resolver.url_patterns[0].callback



Security + optimizations
-----------------

Django wraps views normally with an atomic wrapper, effectively making them into transactions.
For role and permission checking, we must only do read-only lookups. Thus we don't need transactions.
Therefore it's fine to wrap the existing wrapper.



Idiosyncracies
--------------


Django class uses the methods 'get', 'post' etc. to dispatch to the right method view.

REST uses..
