Design
======


Overview
--------

At the core we are creating a permission table. Before running each view,
permissions for the specific view will be tested.

Essentially..

1. Patch all views with a permission checker.
2. Add a view_permissions to each patched view.

> In the past we would use a global PERMISSIONS_REGISTRY. However this is problematic
with REST Framework functions. REST function views all have the same generic name (WrappedView).
We could patch .get and .post but from inside before_view, it's still very hard to
get the name of the current view to use in the lookup table without workarounds.

Patching directly with view_permissions on each view is easier and works in all cases.


## Patching views

Although we intend to patch views when possible. Due to how REST Framework
works we need to patch the check_permissions instead. We use directives to tell
which views to patch. Directives can be a class-based `view_permissions` dict,
global permissions file or a decorator.

> We

    * PATCHING DIAGRAM *

                  function?
    urlpatterns -------------> patch function
         |        
         '-------------------> 1) patch methods based on settings
         class?                2) patch methods based on class view_permissions
                               3) patch method which has view_permissions attached
                                  (decorator directives add this to the decorated methods)

    * PERMISSIONS_REGISTRY DIAGRAM *



    settings.py -- collect permissions --------------- 1) Add rules to PERMISSION_REGISTRY
                                              |        2) Add check_permissions to specified views
    urlpatterns -- collect view_permissions --'

    @allowed, @denied -- (at runtime) ---------------- 1) Add rules to PERMISSION_REGISTRY
                                                       2) Add check_permissions to decorated view

With `check_permissions` we mean our own check_permissions function which utilizes the PERMISSION_REGISTRY

**REST workarounds**

Due to how REST Framework works patching is not as straighforward

  1. We can't patch REST's `check_permissions` since at that time it doesn't know
     which view method it will be dispatched to. Rembmer the flow is like this;
     dispatch() --> initial() --> check_permissions() --> .. view
  2. We can patch the view. That however means that REST's `check_permissions` will
     be prioritized.

Ideally we want the roles to be checked, and REST's `check_permissions` to be the
fallback option. In order to achieve this we do something more complex.

  (Django patched)            (REST)                 (REST patched)
    dispatch                 dispatch                   dispatch
        |                       |                          |
        |              REST check_permissions     REST check_permissions (mocked to do nothing)
        |                       |                          |
     pre_view                  view                    pre_view ------.
        |                                                              |
check_permissions                                              check_permissions
        |                                                              |
        |                                                 REST check_permissions (original)
        |                                                              |
      view                                                view  -------'

## Permission registry

PERMISSION_REGISTRY acts as a lookup table and has the below format:

{
    'authentication.views': {
        'myview': [
          (True, is_admin)
        ]
    }
    'authentication.views.UserViewSet': {
        'create': [
            (True, is_admin, is_authenticated),
        ]
    }
}

Breaking it down

  1. The first key is the path to the view. For methods, this is the class.
  2. Each subkey is a view.
  3. Each view has a list of permissions.
  4. A permission is a tuple where; (a) the first element denotes if permision
     is granted or not and (b), the rest is an arbitrary number of role checkers.


Overall flow
------------


1. collect permissions -> generates PERMISSION_REGISTRY
2. Patch views based on rules in PERMISSION_REGISTRY


The table is generated by 3 avenues:

  1. A main config
  2. Config per view (by a class variable)
  3. Config per view action (by a decorator)

Note that a class can be using decorators, or a class variable, or a combination
of both.

All these avenues are combined. Conflicting configurations will raise a
ImproperlyConfigured exception.


Patching views
--------------

Patching is done slightly different for Django and Django REST. The biggest difference
is that Django REST will call check_permissions() before calling the method view.

## Django

* Function views are patched directly from the resolvers to urlpatterns.
* Class merthod views are patched in case of classes. This ensures that every
  view called by dispatch() will do a check.

## Django REST

Django functions essentially become methods to a WrappedAPI class so we treat both
functions and class-based views the same.

* Patching occurs at the check_permissions() method. We can't patch directly the
  class views like in Django since then check_permissions() would overshadow our
  checks - in many cases not being called at all.

dispatch() --> initial() --> check_permissions() --> get() --> retrieve()


Building permission registry
----------------------------

For convenience we keep a role and permission lookup table stored as PERMISSION_REGISTRY.

The lookup is built by looking in certain places:
  1. Initially we look for a central configuration from Django settings.
  2. Secondly, we look by iterating over urlpatterns:
    - Look at callbacks for view classes with a view_permissions definition.
    - Look at callbacks decorated with @allowed or @disallowed

The lookup table has this structure

    {
        'authentication.views.UserViewSet': {
            'create': [
                (True, is_admin, is_authenticated),
                (False, is_anon),
            ]
        }
    }

Note: the entries in the lookup are sorted based on @expensive and @cheap.


Determining permissions
-----------------------

Permissions are determined by first checking the role of the current user and
secondly checking the permissions for that role.

When check_permissions() is called
  * We loop through the PERMISSION REGISTRY
  * For a matching role, we loop through the permissions
    -


Security + optimizations
-----------------

Django wraps views normally with an atomic wrapper, effectively making them into transactions.
For role and permission checking, we must only do read-only lookups. Thus we don't need transactions.
Therefore it's fine to wrap the existing wrapper.



Idiosyncracies
--------------


Django class uses the methods 'get', 'post' etc. to dispatch to the right method view.

REST uses..
